%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Structured General Purpose Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%   PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage{graphicx} % Required to insert images
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template

\usepackage[T1]{fontenc} % Codificación de las fuentes utilizadas
\usepackage[spanish]{babel} % Español como idioma principal del texto (permite hyphenation de palabras al final de una línea)
\selectlanguage{spanish}
\usepackage{hyperref}
\usepackage{listings}

\input{includes}
\usepackage{float}
%----------------------------------------------------------------------------------------
%   NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Marcologger} % Assignment title
\newcommand{\hmwkDueDate}{Viernes,\ 15\ de\ mayo\ de\ 2015} % Due date
\newcommand{\hmwkAuthorName}{Diego Martín Arroyo} % Your name

\graphicspath{{Figures/}}
%----------------------------------------------------------------------------------------
%   TITLE PAGE
%----------------------------------------------------------------------------------------

\title{\hmwkTitle}
\author{\textbf{\hmwkAuthorName}}
\date{\hmwkDueDate}

%----------------------------------------------------------------------------------------



\begin{document}

\maketitle
\begin{abstract}
Marcologger es una herramienta que permite observar la salida de un programa distribuido desde una única interfaz, integrándose además en rsyslog, utilizando Snorky para la gestión de los WebSockets.
\end{abstract}

%----------------------------------------------------------------------------------------
%   TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

\setcounter{tocdepth}{1}

\tableofcontents
\newpage

\section{Introducción}

El uso de un sistema conformado por varios nodos dificulta su mantenimiento, y en particular la instalación de un conjunto de herramientas iniciales y las posteriores actualizaciones. Dicho mantenimiento, si es llevado a cabo de forma ``manual'' suele propiciar fallos humanos o inconsistencias en el resultado final (nodos que no cuentan con el mismo conjunto de herramientas). Por ello, en el desarrollo del sistema se ha apostado por una herramienta que automatice la instalación del sistema operativo reduciendo al máximo el tiempo de atención que el administrador debe prestar a cada nodo, facilitando además la gestión y actualización posterior..

En el presente documento se detallan las decisiones de usuario llevadas a cabo en el desarrollo de la utilidad \textbf{marco-netinst}, que lleva a cabo este cometido, así como el funcionamiento de dicha herramienta.

\section{Evaluación de alternativas}

Como se define en la memoria del Trabajo, las opciones típicamente utilizadas por administradores de sistemas no son viables en el sistema a construir debido a las características de la plataforma utilizada: los equipos \textbf{Rasbperry Pi} no soportan el protocolo \textbf{PXE}, por lo que es necesario crear una herramienta propia, o buscar alternativas ya existentes creadas para un problema similar.

\subsection{Estrategia inicial}

El arranque de una placa \textbf{Rasbperry Pi} es llevado a cabo principalmente por la GPU de la misma. Al conectarse a la corriente eléctrica, se activa la secuencia de arranque definida en la memoria de solo lectura. Este código busca en la primera partición de la tarjeta SD un \textit{bootloader} y lo carga, activando la memoria SDRAM y pasando al siguiente estado, en el que se carga el archivo start.elf, que carga el Kernel del sistema operativo según los parámetros definidos en los ficheros \texttt{config.txt} (pues no tiene un cargador que indique los parámetros, como ocurre en sistemas de escritorio, en los que existen opciones como GRUB o LILO), \texttt{cmdline.txt} y \textbf{bcm2835.dtb}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.4\textwidth]{bootsequence}
	\caption{Secuencia de arranque de la Raspberry Pi\cite{bootsequence}}
	\label{bootsequence}
\end{figure}

Un archivo de configuración \texttt{cmdline.txt} sin modificar suele seguir la siguiente estructura:

\begin{lstlisting}[frame=single,basicstyle=\small\ttfamily]
root=/dev/mmcblk0p2 rw rootwait console=ttyAMA0,115200 console=tty1 \
selinux=0 plymouth.enable=0 smsc95xx.turbo_mode=N dwc_otg.lpm_enable=0 \
kgdboc=ttyAMA0,115200 elevator=noop
\end{lstlisting}

Los parámetros de interés son los siguientes:

\begin{itemize}
	\item \texttt{root}: Partición raíz a utilizar (generalmente la segunda partición)
	\item \texttt{init}: Especifica el archivo a ejecutar en el arranque. Este proceso tendrá por tanto el \textbf{PID} 1 y generalmente su ejecutable es el fichero \texttt{/sbin/init}\footnote{En sistemas donde \texttt{systemd} es el proceso inicial, \texttt{/sbin/init} es un enlace simbólico al ejecutable de \texttt{systemd}}. Si no se especifica, como ocurre en el archivo por defecto, su valor es este\cite{kernelparams:init}.
\end{itemize}

Modificando el parámetro \texttt{init} es posible ejecutar un código diferente a \texttt{init} en el proceso de arranque, que realice la descarga e instalación del sistema operativo, logrando una solución de compromiso entre la instalación manual y el uso de \textbf{PXE}.

Debido a la falta de experiencia en el desarrollo de herramientas similares, se han seguido varios enfoques:

\section{Primer enfoque: modificación del script de inicio}

En este primer intento se crea un \textit{script} y un ejecutable programado en C con un conjunto mínimo de utilidades que permitan la descarga del sistema operativo. Estos archivos son instalados en la primera partición de la tarjeta SD, siendo correctamente ejecutados. Sin embargo, no es posible llevar a cabo la instalación debido a la falta de herramientas de configuración de red, y el enfoque presenta varios problemas adicionales: al carecer de un proceso \texttt{init}, el sistema operativo es muy inestable, y es difícil realizar cualquier tarea más allá de la gestión de ficheros o tareas de mantenimiento básicas.

\section{Segundo enfoque: Busybox}

\textbf{Busybox} es una utilidad que aglutina un conjunto de herramientas UNIX en un único ejecutable de tamaño muy reducido, reemplazando así el uso de varios paquetes, como fileutils o shellutils. Las utilidades a las que reemplaza cuentan con mucha menos funcionalidad, pero son capaces de crear un sistema utilizable con únicamente un kernel y varios ficheros de configuración\cite{aboutbusybox}. Es la opción más común a la hora de crear sistemas embebidos o para realizar operaciones sin un sistema operativo completo.

Utilizando BusyBox es posible configurar la interfaz de red de la Raspberry Pi mediante \textbf{DHCP} gracias a la herramienta \textbf{udhcpc}, incluida en la distribución de BusyBox estándar, así como a un conjunto de herramientas de utilidad como \textbf{wget}.\\

Incluyendo BusyBox en el código del primer proyecto es posible conseguir acceso a la red, pero el hecho de no utilizar el proceso \textbf{init} dificulta la mayor parte de operaciones, por lo que esta opción es descartada.

\section{Enfoque exitoso}

Antes de detallar la solución definitiva al problema, es necesario detallar las herramientas de terceros valoradas y descartadas:

\subsection*{Raspi-LTSP, PiNET}

Estos proyectos\cite{raspiltsp, pinet} están enfocados a la centralización de toda la información en un servidor, incluyendo la carga del sistema operativo, por lo que no constituyen una opción viable.

\subsection*{BerryBoot}

BerryBoot\cite{berryboot} es un sistema de arranque que posibilita la descarga e instalación de un sistema operativo y la coexistencia de varios en una misma tarjeta SD. Constituye una opción bastante prometedora, que sin embargo depende significativamente de una interfaz gráfica y de un usuario que interaccione con la misma, haciendo que su uso sea inviable para el objetivo deseado sin una intensa reestructuración.

\subsection{Propuesta de solución}

El proyecto \textbf{raspbian-ua-netinst}\cite{raspbian-ua-netinst} posibilita la instalación de la distribución Raspbian desde un repositorio público, realizando el particionado de la tarjeta SD, la descarga e instalación de los ficheros y el resto de tareas necesarias desde la propia máquina, únicamente copiando en la tarjeta unos 15 \textit{megabytes} de información. Este proyecto ha sido adaptado a las necesidades específicas del sistema, con las siguientes modificaciones:

\begin{itemize}
	\item Instalación de \textbf{ArchLinux ARM} en lugar de \textbf{Raspbian}.
	\item Instalación del sistema operativo completo a partir de un archivo \textbf{.tar.gz} en lugar de la descarga de paquetes.
	\item Nuevo \textit{script} de carga del \textit{software} en la tarjeta SD (en el paquete original se delega a utilidades de terceros).
	%TODO\item Posibilidad de aplicar diferentes esquemas de particionado
	\item Detección del servidor sin configuración previa utilizando \textbf{MarcoPolo}.
	%TODO\item Interfaz administrativa de los sistemas operativos ofrecidos
\end{itemize}

El sistema se compone de varios componentes, como se detalla en la siguiente sección.

\section{marco-netinst}

\textbf{marco-netinst} está compuesto por un conjunto de herramientas que permiten la gestión de los nodos del sistema y la instalación del sistema operativo en los mismos. Para ello se compone de varios módulos:

\subsection{marco-netinst}

Este módulo, basado en \textbf{raspbian-ua-netinst} únicamente comprende varios scripts, detallados a continuación:

\subsubsection*{update.sh}

Descarga del repositorio indicado los paquetes que necesita el sistema operativo para arrancar. Dichos paquetes consisten básicamente en código de arranque, \textit{kernels}, bibliotecas y un conjunto de herramientas básicas, siendo la más importante de ellas \textbf{BusyBox}. El \textit{script} realiza la descarga en un directorio temporal de los archivos \textbf{.deb}.

\subsubsection*{build.sh}

Crea los archivos necesarios para la instalación, que deberán ser copiados a la tarjeta SD. Para ello, realiza la siguiente secuencia de acción:

\begin{enumerate}
\item Copia del \textit{kernel}.
\item Creación de los archivos de configuración.
\item Creación de los archivos \textbf{.cpio} (uno por cada arquitectura) que aglutina todas las bibliotecas, ejecutables y otros archivos de interés, así como los \textit{scripts} que llevarán a cabo la instalación del sistema operativo. 
\item Creación de los parámetros de la línea de comandos.
\item Copia de las utilidades de \textbf{MarcoPolo}.
\item Creación de un fichero \textbf{.zip}.
\end{enumerate}

\subsubsection*{deploy.sh}

Formatea la tarjeta SD, creando una única partición, donde descomprime el archivo \textbf{.zip} creado anteriormente.

Estos tres \textit{scripts} deben ser ejecutados en el orden en el que han sido expuestos, pues dependen de los archivos generados por el resto. En caso de que no se realice la llamada de uno sin su antecesor, este procederá a su ejecución antes de realizar la funcionalidad que le corresponde.

\subsubsection*{clean.sh}

Elimina todos los ficheros temporales y el resultado de las ejecuciones.

La mayoría de los archivos temporales que son descargados se conservan y son reutilizados en posteriores ejecuciones, optimizando el tiempo de instalación en varias máquinas.

\subsection{marco-bootstrap}

Ejecutable en C++ que permite llevar a cabo el descubrimiento del servidor donde se aloja el sistema operativo mediante \textbf{MarcoPolo}. Debido a la ausencia del \textit{daemon} de \textbf{Marco} en la imagen mínima copiada a la tarjeta SD, se utiliza una implementación básica del protocolo, denominada \textbf{marco-minimal}. Esta implementación expone la misma funcionalidad que el \textbf{binding} de Marco en C++, pero a más bajo nivel.

\subsection{marco-bootstrap-backend}

Interfaz de gestión de los sistemas operativos que el servidor ofrece para su descarga.

\section{Instalación}

El conjunto de herramientas que realizan la instalación del sistema operativo están basadas en \textbf{Debian}, y por tanto utilizan el gestor de arranque \textbf{init}. Para realizar la instalación por tanto se delegará la ejecución de los \textit{scripts} que realicen las funciones a dicho gestor. Por ello, se define el script \texttt{/etc/rcS}, que es ejecutado en cualquier nivel de ejecución (\textit{runlevel})\footnote{\href{http://apt-browse.org/browse/ubuntu/trusty/main/all/sysv-rc/2.88dsf-41ubuntu6/file/etc/rcS.d/README}{apt-browse.org/browse/ubuntu/trusty/main/all/sysv-rc/2.88dsf-41ubuntu6/file/etc/rcS.d/README}}. 

El script lleva a cabo la siguiente secuencia de tareas:

\begin{enumerate}
	\item Define una serie de variables de utilidad.
	\item Crea de directorios necesarios dentro de la tarjeta SD.
	\item ``Instala'' todas las utilidades de \textbf{BusyBox} (permite el acceso a las mismas) y define las rutas de búsqueda de ficheros mediante la variable \texttt{\$PATH}.
	\item Monta de los pseudosistemas de ficheros \texttt{/proc} y \texttt{/sys}.
	\item Establece mecanismos de redirección de una copia de las salidas estándar y de error (\textbf{stdout} y \textbf{stderr}) a un fichero de log para su posterior análisis.
	\item Determina el tipo de \textit{hardware} sobre el que se está ejecutando el \textit{script}, a fin de instalar versión del sistema operativo apropiada.
	\item Copia los ficheros de arranque contenidos en la tarjeta SD.
	\item Carga un \textit{script} con parámetros adicionales definidos por el usuario.
	\item Configura de la interfaz de red \textbf{eth0} mediante \textbf{DHCP}.
	\item Determina de la hora mediante \textbf{NTP}.
	\item Carga módulos del \textit{kernel} si son necesarios.
	\item Particiona la tarjeta SD según el siguiente esquema:
	\begin{itemize}
		\item Partición 1: 128 megabytes, formato FAT32.
		\item Partición 2: Resto de la tarjeta SD, formato ext4.
	\end{itemize}
	\item Busca de servidores que alojen el sistema operativo mediante \textbf{MarcoPolo}.
	\item Descarga el sistema operativo como archivo \texttt{.tar.gz}.
	\item Descomprime el sistema operativo en la partición número 2 (donde la mayoría de ficheros se almacenan. La estructura del fichero \texttt{.tar.gz} define el lugar donde cada fichero se debe alojar, y los permisos de acceso a los ficheros son conservados en el proceso de extracción, por lo que con la extracción se consigue además la estructuración del sistema y la gestión de permisos).
	\item Mueve los ficheros de arranque a la partición 1 (\textit{kernel}, parámetros de arranque, etcétera).
	\item Ejecuta los \textit{scripts} de post-instalación.
	\item Almacena el fichero de log.
	\item Limpia archivos temporales.
	\item Desmonta los sistemas de ficheros y procede al reinicio del sistema.
\end{enumerate}

Una vez ejecutado el script el nodo está preparado para integrarse en el sistema. El tiempo total de instalación es de unos 5 minutos, según el fichero de log, dependiendo del estado de la red. En pruebas realizadas, el tiempo de descarga supone aproximadamente la mitad del tiempo total de instalación, si bien mejora significativamente cuando se cuenta con un servidor local que aloje el sistema operativo.

\section{Actualización}

El administrador puede programar actualizaciones utilizando la herramienta de backend y enviar notificaciones a los diferentes nodos del sistema. Estos realizarán la actualización en el siguiente reinicio del sistema, o si lo desea el administrador, de forma programada o inmediata.

El administrador únicamente debe subir a la interfaz web una imagen del sistema operativo a replicar, que incluirá todos los paquetes necesarios. Los nodos reemplazarán su sistema operativo por este mediante un proceso similar al de instalación.

Para realizar la creación de la imagen existe la herramienta \texttt{createimage.sh}, que requiere como parámetro un descriptor de dispositivo (una tarjeta SD o un archivo .img) que contenga los archivos a copiar.

Los nodos cuentan con un servicio (vinculado a MarcoPolo) que escucha peticiones (verificadas por un certificado SSL) de actualización (o cualquier otra funcionalidad que pueda ser añadida, apostando por la versatilidad en el desarrollo de la plataforma). Al recibir una petición válida (el certificado enviado pertenece a un servidor de despliegue), comienza el siguiente proceso:

\begin{itemize}
	\item Comprueban los parámetros de la petición, y actúan en consecuencia.
	\item En el caso de que se solicite una actualización, se leen los parámetros de la petición, que incluyen el momento de reinicio y el nombre del fichero a solicitar al servidor.
	\item Copia a la partición 1 (arranque) los ficheros kernel.img, paquetes Debian necesarios, Busybox y el script /etc/init/rcS, que en caso de ser necesario, deberá ser modificado para atender a las características propias de cada consulta.
	\item Programa un reinicio del sistema en el momento definido por el administrador (inmediatamente, en un momento determinado o en el momento en el que se produzca un reinicio originado por otra causa).
	\item Al reiniciarse se realiza una secuencia de pasos similar a la del proceso de instalación.

\end{itemize}

A fin de no eliminar la información almacenada por los usuarios, o cualquier otro tipo de datos que deban sobrevivir a este tipo de actualizaciones, se definirán particiones que no serán alteradas.

\section{Tiempo}

El tiempo de interacción que el administrador debe emplear por cada máquina es de aproximadamente un minuto, el tiempo necesario para conectar una tarjeta SD, ejecutar el script de carga de los paquetes de instalación, y la desconexión de la misma.

El tiempo de instalación es variable, dependiente principalmente de la velocidad de descarga del sistema operativo y el tiempo de descompresión y copia de este, si bien suele ser inferior a 10 minutos (y este tiempo es paralelo para todas las máquinas, suponiendo únicamente una mayor carga para el servidor).

\section{Evaluación}

Se han realizado las siguientes evaluaciones de uso:

\begin{itemize}
	\item Entrevista con el Administrador de la instalación el día 13 de mayo, donde se le presenta la solución propuesta y los resultados obtenidos. Según su criterio considera que el enfoque es el adecuado.

\end{itemize}
\nocite{rpiconfig}

 \label{Bibliography}
 \lhead{\emph{Bibliografía}}  % Change the left side page header to "Bibliography"
 \bibliographystyle{ieeetr}  % Use the "unsrtnat" BibTeX style for formatting the Bibliography
 \bibliography{marcobootstrap}  % The references (distcc) information are stored in the file named "distcc.bib"

\end{document}
